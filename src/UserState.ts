/*if (!('window' in global)) {
    global['window'] = { navigator: { userAgent: 'nodejs' } };
}*/

import {
  applyMiddleware,
  compose,
  createStore,
  Dispatch,
  Middleware,
  MiddlewareAPI,
  Reducer,
  Store,
  StoreEnhancer
} from 'redux'
import {
  default as createSagaMiddleware,
  END,
  SagaIterator,
  SagaMiddleware,
  Task
} from 'redux-saga'
import DomainManager from './DomainManager'
import Saga from './types/Saga'
import createReducer from './helpers/createReducer'
import createRootSaga from './helpers/createRootSaga'
import KeyDomainMap from './types/KeyDomainMap'

interface WindowWithReduxDevTools {
  __REDUX_DEVTOOLS_EXTENSION_COMPOSE__: any;
}

function isWindowWithReduxDevTools(window: any): window is WindowWithReduxDevTools {
  return (
    typeof window === 'object' &&
    typeof window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ === 'function'
  )
}

export interface UserStoreOptions {
  /**
   * The final combined redux `reducer` which is passed to the redux `createStore` function
   */
  reducer?: Reducer<any>;

  /**
   * The `preloadedState` argument which is passed to the redux `createStore` function.
   * Commonly used to set the redux state generated by server-side rendering.
   * Internals: `redux` overrides every defined sub-state - undefined sub-state's are set to the `defaultState`.
   * Note: The `defaultState` is set in the reducer (2nd argument in `handleActions` from `redux-actions`).
   */
  preloadedState?: any;

  /**
   * Apply additional redux middlewares (before the saga middleware)
   */
  middlewares?: Middleware[];

  /**
   * Apply additional redux enhancers (before the sagaMiddleware and your other defined middlewares)
   */
  enhancers?: StoreEnhancer<any>[];

  /**
   * default is true
   * If true, the redux store can be debugged with `Redux DevTools` browser extension if available (Chrome/Firefox/Electron).
   * This takes effect if using the underlaying https://github.com/zalmoxisus/remote-redux-devtools
   * Notes: `redux` `compose` function get replaced by  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
   * See: https://github.com/zalmoxisus/redux-devtools-extension
   *
   * For none-supported browser/react-native you should use following one (no implemented here currently):
   * https://github.com/gaearon/redux-devtools
   * https://github.com/zalmoxisus/remote-redux-devtools
   */
  reduxDevToolsCompose?: boolean;

  /**
   * default is false
   * If true, the `createStore` function is replaced by the Reactotron's one,
   * and the sagaMonitor is set to Reactotron.createSagaMonitor().
   * The Reactotron object must be availiable in the current scope (or window/global object)
   * with the `reactotron-redux` and `reactotron-redux-saga` plugins enabled (Reactotron.use method).
   * This library don't create a hard dependency to Reactotron, so you have to do it previously.
   */
  reactotron?: boolean;

  /**
   * The saga (generator function) which should be automatically run by the `sagaMiddleware`.
   * It should fork several sagas which on the other hand listen for actions (with takeEvery/takeLatest)
   * The methods `startRootSaga`, `finalizeSaga` are controlling this root saga.
   */
  rootSaga?: () => SagaIterator;
};

/**
 * The UserState creates a scoped redux store with a saga middleware.
 * It starts the root saga automatically which whose fork listen to redux actions.
 * You can define additional middlewares/enhancers or the preloadedState for the redux store.
 * Supports Reactotron and Redux DevTools by enabling the flags.
 */
export default class UserStore<DM extends DomainManager<any, any>> {
  /** The DomainManager which was given in the constructor */
  public readonly domainManager: DM;

  /** The created redux store. */
  public readonly store: Store<any>;

  private _sagaMiddleware: SagaMiddleware;
  private _rootSagaTask: Task;

  constructor(
    domainManager: DM,
    private options?: UserStoreOptions
  ) {
    this.domainManager = domainManager;

    const defaultOptions: UserStoreOptions = {
      reducer: () => ({}),
      preloadedState: {},
      middlewares: [],
      enhancers: [],
      rootSaga: function* () { },
      reduxDevToolsCompose: true,
      reactotron: false,
    };

    let optionsByDomainManager = {};
    if (this.domainManager) {
      optionsByDomainManager = new.target.generateOptionsByDomainManager(this.domainManager);
    }

    this.options = Object.assign({}, defaultOptions, options, optionsByDomainManager);

    let createStoreFn = createStore;
    let composeFn: any = compose;
    let sagaMiddlewareOptions: any = {};

    if (
      typeof (window) !== 'undefined' &&
      this.options.reduxDevToolsCompose === true &&
      isWindowWithReduxDevTools(window)
    ) {
      composeFn = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__;
    }

    if (this.options.reactotron === true) {
      if (typeof Reactotron === 'undefined') {
        throw new Error(`Reactotron object is not defined in the global scope.`);
      }
      if (typeof Reactotron.createStore !== 'function') {
        throw new Error(`Reactotron must 'use' reactotron-redux plugin.`);
      }
      if (typeof Reactotron.createSagaMonitor !== 'function') {
        throw new Error(`Reactotron must 'use' reactotron-redux-saga plugin.`);
      }

      createStoreFn = Reactotron.createStore;
      sagaMiddlewareOptions = {
        sagaMonitor: Reactotron.createSagaMonitor(),
        // onError: unhandled exceptions for a saga
      };
    }

    // sagaMiddlewareOptions.onError = function() {}
    // @TODO: remove this/comment this out
    sagaMiddlewareOptions.emitter = emit => {
      return action => {
        emit(action);
        console.log('saga emit', action.type);
      }
    }

    this._sagaMiddleware = createSagaMiddleware(sagaMiddlewareOptions);

    let middlewares = [
      ...this.options.middlewares,
      this._sagaMiddleware,
    ];

    let composedEnhancer = composeFn(...[
      ...this.options.enhancers,
      ...middlewares.map(middleware => applyMiddleware(middleware)),
    ]);

    this.store = createStoreFn(
      this.options.reducer,
      this.options.preloadedState,
      composedEnhancer,
    );

    this.startRootSaga();

    domainManager.store = this.store;

    if (process.env.NODE_ENV !== 'production' && typeof (window) !== 'undefined') {
      // maybe option: expose this instance to window object as "userState"
      console.info('The current user state is exposed under the `userState` property on the window object.');
      (window as any).userState = this;
    }

    // Dispatches startup sagas on domains if any
    this.store.dispatch({ type: '@@STARTUP' });
  }

  /**
   * Used internally to create the final `reducer` and `rootSaga` option by the given DomainManager
   * Uses the separated helper functions (createReducer and createRootSaga) to create them.
   */
  private static generateOptionsByDomainManager(
    domainManager: DomainManager<any, any>
  ) {
    const domainReducer = domainManager.getReducers();
    const domainDefaultStates = domainManager.getDefaultStates();
    const domainSaga = domainManager.getSagas();

    const reducer = createReducer(domainReducer, domainDefaultStates/*, options.reducer*/);
    const rootSaga = createRootSaga(domainSaga/*, options.rootSaga*/);

    return {
      reducer,
      rootSaga,
    };
  }

  /**
   * Returns the root saga task
   */
  public get rootSagaTask() {
    return this._rootSagaTask;
  }

  /**
   * The store root state. Shortcut to: userState.store.getState()
   */
  public get state(): any {
    return this.store.getState();
  }

  /**
   * Domains map. Shortcut to: userState.domainManager.domain
   */
  public get domains() {
    return this.domainManager.domains;
  }

  /**
   * Domains map. Shortcut to: userState.domainManager.resetAllStates
   */
  public resetAllStates() {
    this.domainManager.resetAllStates();
  }

  /**
   * Run the configured root saga from the options.
   */
  public startRootSaga() {
    if (this.rootSagaTask && this.rootSagaTask.isRunning()) {
      throw new Error('Cannot start root saga because it is already running.');
    }
    this._rootSagaTask = this._sagaMiddleware.run(this.options.rootSaga);
  }

  /**
   * Dispatches the END action and waits until all tasks in the root saga task are finished.
   * Then start a fresh root saga automatically if restart param is true (default).
   */
  async finalizeRootSaga(restart: boolean = true) {
    if (!this.rootSagaTask.isRunning()) {
      return Promise.resolve();
    }

    this.store.dispatch(END);

    const rootTaskResult = await this.rootSagaTask.done;
    if (restart === true) {
      this.startRootSaga();
    }

    return rootTaskResult;
  }

  /**
   * Quick debugging the status of the root saga
   */
  public getRootSagaStatus() {
    const running = this.rootSagaTask.isRunning();
    const cancelled = this.rootSagaTask.isCancelled();
    const error = this.rootSagaTask.error();
    const result = this.rootSagaTask.result();
    return {
      running,
      cancelled,
      error,
      result,
      toString() {
        if (running) {
          return 'Root saga is running.'
        } else if (cancelled) {
          return 'Root saga has been cancelled.'
        } else if (result) {
          return 'Root saga is not running, it returned ' + result
        } else if (error) {
          return 'Root saga is not running, it returned an error ' + error
        } else {
          return 'Root saga is not running'
        }
      }
    };
  }
}

/**
Test if this could work somehow
If any domain class changed:
-> refetch all reducers, replace the final reducer in redux store
    this.store.replaceReducer(newReducer);
-> refetch all sagas, cancel the previous rootSaga (this.rootSagaTask.cancel()), start the new created root saga

// check if HMR is enabled
if(module.hot) {
    // accept update of dependency
    module.hot.accept("./handler.js", function() {
        // replace request handler of server
        server.removeListener("request", requestHandler);
        requestHandler = require("./handler.js");
        server.on("request", requestHandler);
    });
}
*/
